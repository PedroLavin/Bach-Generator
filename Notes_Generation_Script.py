import pickle
import numpy as np
from tensorflow.keras.models import load_model
from music21 import stream, note, chord, duration, tempo, midi
import random

# Load the trained model and data
print("Loading trained model and data...")
model = load_model('best_weights.h5')

with open('model_info.pkl', 'rb') as f:
    model_info = pickle.load(f)

with open('training_data.pkl', 'rb') as f:
    training_data = pickle.load(f)

n_vocab = model_info['n_vocab']
note_to_int = model_info['note_to_int']
int_to_note = model_info['int_to_note']
vocabulary = model_info['vocabulary']

print(f"Model loaded! Vocabulary size: {n_vocab}")

def generate_notes(model, network_input, int_to_note, n_vocab, num_notes=200):
    """Generate a sequence of notes using the trained model"""
    
    # Pick a random sequence from the input as a starting point
    start = np.random.randint(0, len(network_input)-1)
    pattern = network_input[start]
    prediction_output = []
    
    print(f"Generating {num_notes} notes...")
    print("Starting pattern from training data...")
    
    # Generate notes
    for note_index in range(num_notes):
        # Reshape pattern for prediction
        prediction_input = np.reshape(pattern, (1, len(pattern), 1))
        prediction_input = prediction_input / float(n_vocab)
        
        # Get prediction from model
        prediction = model.predict(prediction_input, verbose=0)
        
        # Convert prediction to note index
        # Use some randomness to make it more interesting
        temperature = 1.0  # Higher = more random, lower = more conservative
        prediction = np.log(prediction + 1e-7) / temperature
        exp_preds = np.exp(prediction)
        prediction = exp_preds / np.sum(exp_preds)
        
        index = np.random.choice(range(len(prediction[0])), p=prediction[0])
        
        # Convert back to note
        result = int_to_note[index]
        prediction_output.append(result)
        
        # Update pattern for next prediction (remove first note, add new one)
        pattern = np.append(pattern[1:], index)
        
        if note_index % 50 == 0:
            print(f"Generated {note_index} notes...")
    
    print("Generation complete!")
    return prediction_output

def create_midi_from_notes(prediction_output, filename="generated_bach.mid"):
    """Convert the generated notes to a MIDI file"""
    
    offset = 0
    output_notes = []
    
    # Create note and chord objects based on the values generated by the model
    for pattern in prediction_output:
        # Pattern is a chord
        if ('.' in pattern) or pattern.isdigit():
            notes_in_chord = pattern.split('.')
            notes = []
            for current_note in notes_in_chord:
                try:
                    new_note = note.Note(int(current_note))
                    notes.append(new_note)
                except:
                    # Skip invalid notes
                    continue
            if notes:  # Only create chord if we have valid notes
                new_chord = chord.Chord(notes)
                new_chord.offset = offset
                output_notes.append(new_chord)
        # Pattern is a note
        else:
            try:
                new_note = note.Note(pattern)
                new_note.offset = offset
                output_notes.append(new_note)
            except:
                # Skip invalid notes
                continue
        
        # Increase offset each iteration so that notes don't stack
        offset += 0.5
    
    # Create a stream and add the notes
    midi_stream = stream.Stream(output_notes)
    
    # Add some basic musical elements
    midi_stream.append(tempo.TempoIndication(number=120))  # 120 BPM
    
    # Write to MIDI file
    midi_stream.write('midi', fp=filename)
    print(f"MIDI file saved as: {filename}")
    
    return midi_stream

# Generate new Bach-style music!
print("Generating new Bach-style music...")

# Load the network input for starting patterns
network_input = training_data['network_input']
sequence_length = len(network_input[0])
network_input = np.reshape(network_input, (len(network_input), sequence_length, 1))

# Generate new Bach-style music with the fixed function!
print("Generating new Bach-style music...")

# Generate music (use the same generation code as before)
generated_notes = generate_notes(
    model=model, 
    network_input=network_input, 
    int_to_note=int_to_note, 
    n_vocab=n_vocab, 
    num_notes=200
)

# Convert to MIDI with fixed function
midi_stream = create_midi_from_notes(generated_notes, "my_generated_bach.mid")

print("\nðŸŽµ SUCCESS! ðŸŽµ")
print("Your AI-generated Bach piece is ready!")
